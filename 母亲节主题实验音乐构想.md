

# 母亲节主题实验音乐构想

> 作者：丁佳城	班级：21传媒大数据

## 1 想法

- 首先收集若干首与母亲有关的古典音乐，提取出其主旋律。
- 通过某种算法将这若干个旋律进行平均（或类似的处理），形成一段声音序列。
- 使用某种方法实现该声音序列。

> 说明：该想法实验性质较强，不负责最终声音效果音乐性，编程部分在ChatGPT4的帮助下完成。另外由于时间紧促，仅提取了勃拉姆斯《F大调摇篮曲》与舒伯特《摇篮曲》共9个片段进行实验，实验结果见output_audio.wav

## 2 目标乐曲

1、勃拉姆斯《F大调摇篮曲》

2、舒伯特《摇篮曲》

3、莫扎特《Ah vous dirai-je, Maman》

4、莫扎特《Violin Sonata No. 18 in G Major, KV301》

5、贝多芬《F大调浪漫曲》

6、德沃夏克《母亲教我的歌》

## 3 步骤

### 3.1 录入并处理数据

- 首先记变量$X$为某个音$M$音高的数值，基准音$A0$的$X$值为$0$，在十二平均律的基础上进行音分转换，如第二个音$A\#0$的值记为$100$，以此类推.

- 规定休止符的$X$为空

- 设$M$的时值为$T$，记录下旋律片段对应的的二元组$(X,T)$.

- 定义乐句序列$R=[(X_1,T_1),(X_2,T_2),…,(X_n,T_n)]$，乐句序列集合为$S$.

- 提取每一个乐曲中所有旋律乐句，记$R_{i·}$为第$i$个乐曲，$R_{·j}$为第$j$个乐句，$r_{ijk}$为第$i$个乐曲第$j$个乐句的第$k$个音，$X_{ijk}$与$T_{ijk}$以此类推.

### 3.2 正则化

> 此处试图将不同乐句的时长缩放到相同位置

- 设序列的长度为$l=L(R)$，更新所有乐句使$R=[(X_1,l^{-1}T_1),(X_2,l^{-1}T_2),…,(X_n,l^{-1}T_n)]$.

### 3.3 对X与T进行平均处理

- 将划分时间间隔，保证在每一个时刻内音高为$X$的平均数.
- 由于这些乐曲都是采用十二平均律，设基准音的频率为$f_{A_0}=27.500$，任意一音$\alpha$与基准音的音程为$n$个半音，则$f_{\alpha}=f_{A_0}·2^{X/1200}$.
- 将序列中所有$X'$换算为频率产生新的序列文件.

### 实现：序列转换

```python
import re
import math
import matplotlib.pyplot as plt

def parse_melody(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
    
    melodies = []
    for line in lines:
        if line.strip():
            notes = re.findall(r'\((.*?)\)', line)
            melody = []
            total_duration = 0
            for note in notes:
                note_info = note.split(',')
                if len(note_info) == 2:
                    pitch = note_info[0].strip()
                    duration = float(note_info[1].strip())  # 改为 float
                    melody.append((pitch, duration))
                    total_duration += duration
                elif len(note_info) == 1:
                    pitch = note_info[0].strip()
                    melody.append((pitch, None))
            melodies.append((melody, total_duration))
    
    return melodies

def pitch_to_cents(pitch):
    if not pitch:
        return None

    base_pitch = 'A0'
    cents_per_semitone = 100
    pitch_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
    note, octave = pitch[:-1], int(pitch[-1])
    base_note, base_octave = base_pitch[:-1], int(base_pitch[-1])
    semitones = (octave - base_octave) * 12 + pitch_order.index(note) - pitch_order.index(base_note)
    cents = semitones * cents_per_semitone
    return cents

def update_melodies(melodies):
    updated_melodies = []
    for melody, total_duration in melodies:
        updated_melody = []
        for pitch, duration in melody:
            if duration is not None and total_duration != 0:
                updated_duration = duration / total_duration
            else:
                updated_duration = None
            updated_melody.append((pitch, updated_duration))
        updated_melodies.append(updated_melody)
    return updated_melodies

def calculate_dynamic_averages(melodies):
    end_times = set()
    for melody in melodies:
        current_time = 0
        for pitch, duration in melody:
            if duration is not None:
                current_time += duration
                end_times.add(current_time)

    end_times = sorted(end_times)
    
    averages = []
    last_time = 0
    for time in end_times:
        sum_cents = 0
        count = 0
        for melody in melodies:
            current_time = 0
            for pitch, duration in melody:
                if duration is not None:
                    if last_time <= current_time < time and current_time + duration >= last_time:
                        if pitch and pitch != '' and pitch_to_cents(pitch) is not None:
                            sum_cents += pitch_to_cents(pitch)
                            count += 1
                    current_time += duration
        average_cents = sum_cents / count if count > 0 else None
        averages.append((last_time, time, average_cents))
        last_time = time

    return averages


def cents_to_frequency(cents):
    f_A0 = 27.500
    if cents is None:
        return None
    return f_A0 * 2 ** (cents / 1200)

def plot_averages(averages):
    plt.rcParams['font.sans-serif']=['SimHei'] # 用来正常显示中文标签
    plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号
    times = [start for start, end, average in averages]
    averages_cents = [average for start, end, average in averages]
    plt.figure(figsize=(10, 6))
    plt.plot(times, averages_cents, marker='o')
    plt.title("平均音分随时间的变化")
    plt.xlabel("时间 (归一化)")
    plt.ylabel("音分 (Cents)")
    plt.grid(True)
    plt.show()

def save_final_sequence(sequence, file_path):
    with open(file_path, 'w') as file:
        for freq, duration in sequence:
            file.write(f"({freq}, {duration:.6f})\n")  # 保留小数点后六位

def main():
    n_seconds = 30  # 你可以设置这个值为任何你需要的秒数
    melodies_path = 'melodies.txt'
    output_path = 'average.txt'
    melodies = parse_melody(melodies_path)
    normalized_melodies = update_melodies(melodies)
    dynamic_averages = calculate_dynamic_averages(normalized_melodies)

    # 计算归一化总持续时间，它应该是1
    normalized_total_duration = sum(end - start for start, end, _ in dynamic_averages)
    # 计算拉伸因子
    stretch_factor = n_seconds / normalized_total_duration

    final_sequence = []
    for start, end, average in dynamic_averages:
        duration = (end - start) * stretch_factor
        frequency = cents_to_frequency(average) if duration >= 0.05 else None
        final_sequence.append((frequency, duration))

    print("最终序列 (频率, 时值):")
    for freq, duration in final_sequence:
        print(f"({freq}, {duration:.6f})")
    
    save_final_sequence(final_sequence, output_path)
    plot_averages(dynamic_averages)


if __name__ == "__main__":
    main()

```

### 实现：midi序列提取

将目标midi文件放在文件夹中，采用算法将midi乐句解析成所述序列文件。

```python
import pretty_midi
import os

def midi_number_to_note_name(midi_number):
    note_names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
    octave = (midi_number // 12) - 1
    note_name = note_names[midi_number % 12]
    return f"{note_name}{octave}" if midi_number >= 0 else None

def generate_sequence(midi_file):
    midi_data = pretty_midi.PrettyMIDI(midi_file)
    tempo = midi_data.estimate_tempo()
    beat_length = 60 / tempo  # 每拍的秒数

    events = []

    for instrument in midi_data.instruments:
        for note in instrument.notes:
            start_event = (note.start, note.pitch, 'on')
            end_event = (note.end, note.pitch, 'off')
            events.extend([start_event, end_event])

    events.sort()

    sequence = []
    last_time = 0
    active_notes = {}

    for i, event in enumerate(events):
        time, pitch, event_type = event
        if time > last_time and not active_notes:
            rest_duration = (time - last_time) / beat_length
            if rest_duration > 0:
                sequence.append(('', rest_duration))

        if event_type == 'on':
            active_notes[pitch] = time
        elif event_type == 'off' and pitch in active_notes:
            actual_start_time = active_notes[pitch]
            actual_duration = time - actual_start_time
            note_duration_in_beats = actual_duration / beat_length
            sequence.append((midi_number_to_note_name(pitch), note_duration_in_beats))
            del active_notes[pitch]

        last_time = time

    end_time = midi_data.get_end_time()
    if end_time > last_time and not active_notes:
        final_rest_duration = (end_time - last_time) / beat_length
        sequence.append(('', final_rest_duration))

    return sequence

def process_multiple_midis(midi_folder, output_file):
    midi_files = [os.path.join(midi_folder, f) for f in os.listdir(midi_folder) if f.endswith('.mid')]
    with open(output_file, 'w') as file:
        for midi_file in midi_files:
            sequence = generate_sequence(midi_file)
            sequence_text = ','.join(f"({note if note else ''},{duration:.2f})" for note, duration in sequence)
            file.write(sequence_text + "\n")

# Example usage
midi_folder = 'midi'  # 替换为你的 MIDI 文件夹路径
output_file = 'melodies.txt'  # 输出文件路径
process_multiple_midis(midi_folder, output_file)

```

### 实现：音频生成

采用`pydub`包生成正弦波音频

```
from pydub import AudioSegment
from pydub.generators import Sine

def parse_sequence(file_path):
    frequency_duration_pairs = []
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line in lines:
            if line.strip():
                data = line.strip('()\n').split(',')
                frequency = None if data[0] == 'None' else float(data[0])
                duration = float(data[1])
                frequency_duration_pairs.append((frequency, duration))
    return frequency_duration_pairs

def create_audio(frequency_duration_pairs, output_path):
    combined = AudioSegment.silent(duration=0)
    for freq, duration in frequency_duration_pairs:
        if freq is not None:
            sine_wave = Sine(freq)
            audio_segment = sine_wave.to_audio_segment(duration=int(duration * 1000))
            combined += audio_segment
        else:
            silence = AudioSegment.silent(duration=int(duration * 1000))
            combined += silence
    combined.export(output_path, format='wav')

# 路径可能需要根据实际情况修改
sequence_path = 'average.txt'
output_audio_path = 'output_audio.wav'

# 解析频率和时长序列
sequence = parse_sequence(sequence_path)

# 生成并保存音频文件
create_audio(sequence, output_audio_path)

print(f"音频文件已生成并保存为：{output_audio_path}")
```

